Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.


Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java
Clojure

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.


 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                    compilers
                        |
                      .class
                        |
                       jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

caller
make io request-----------------------------Kernal----FD TABLE---new Entry will be added
                                            
                                            entry-----talk---io device--delay---io ready
                                            < ---

fs.close()---------------------------------------kernal fd table--entry to be removed


///////////////////////////////////////////////////////////////////////////////////////////

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Asynchronous programming with non-blocking I/O:

Instead of waiting for I/O operations to complete, we can shift to non-blocking I/O.

You may have already sampled this with the select function in C.


The idea behind non-blocking I/O is to request a (blocking) operation, and move on to doing other tasks until the operation is ready.

For example a non-blocking read may ask for up to 256 bytes over a network socket, and the execution thread does other things (like dealing with another connection) until data has been put into the buffers, ready for consumption in memory.

In this model, many concurrent connections can be multiplexed on a single thread, as network latency typically exceeds the CPU time it takes to read incoming bytes.


Low Level System calls for non blocking:

I/O multiplexing
I/O multiplexing is the the ability to perform I/O operations on multiple file descriptors. Input operations like read, accept and calls for receiving messages block when there is no incoming data. So, if an input call is made and it blocks, we may miss data from other file descriptors. To circumvent this, I/O multiplexing calls, viz., select, poll, and the epoll API calls, are provided. A process blocks on an I/O multiplexing call. When this call returns, the process is provided a set of file descriptors which are ready for I/O. And, the process can do I/O on these file descriptors before it goes for the next iteration of the I/O multiplexing call

1.select
2.poll
3.  aio_read - asynchronous read

1.select:
select is a system call and application programming interface (API) in Unix-like and POSIX-compliant operating systems for examining the status of file descriptors of open input/output channels.

select() allows a program to monitor multiple file descriptors,
       waiting until one or more of the file descriptors become "ready" for
       some class of I/O operation (e.g., input possible).  A file
       descriptor is considered ready if it is possible to perform a
       corresponding I/O operation (e.g., read(2), or a sufficiently small
       write(2)) without blocking.


       select() can monitor only file descriptors numbers that are less than
       FD_SETSIZE; poll and epoll  do not have this limitation. 

2.poll:
poll is a POSIX system call to wait for one or more file descriptors to become ready for use
poll, ppoll - wait for some event on a file descriptor.

Select has lot of drawbacks.

Poll is fundamentally is event driven.
Poll listens for file descriptor events.


https://man7.org/linux/man-pages/man2/poll.2.html

Other advanced implementations:

1.kqueue, 
2.epoll, 
3./dev/poll
4.I/O completion ports



epoll - I/O event notification facility

-event poll api
-monitors multiple file descriptors
-specific to linux

Kernel queue (kqueue)
If you are programming with asynchronous (non-blocking) frameworks, then most likely this framework is using kernel polling APIs under the hood. Using an infinite loop, kernel polling APIs check for events and notify the caller when an event has occurred. 
 For example when an HTTP request is fired, in each iteration of the loop a check is done to see if data already has returned from the server. 

Linux uses epoll
BSD and OSX use kqueue
Windows uses IOCP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Event Loop:
..........
events are picked up solely from epoll and ‘dispatched’ on the same thread within each loop iteration to our request handler ‘app’.

java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.


NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.


NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


///////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vertx uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Simple Vertx Event loop simulation:
package com.ibm.eventloop;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.function.Consumer;

public final class EventLoop {

    //event queue
    private final ConcurrentLinkedDeque<Event> events = new ConcurrentLinkedDeque<>();
    //handler ; key-value binding
    private final ConcurrentHashMap<String, Consumer<Object>> handlers = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        EventLoop eventLoop = new EventLoop();

        new Thread(() -> {
            for (int n = 0; n < 6; n++) {
                delay(1000);
                //event dispatch
                eventLoop.dispatch(new EventLoop.Event("tick", n));
            }
            eventLoop.dispatch(new EventLoop.Event("stop", null));
        }).start();

        new Thread(() -> {
            delay(2500);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful world" + Thread.currentThread().getName()));
            delay(800);
            eventLoop.dispatch(new EventLoop.Event("hello", "beautiful universe"));
        }).start();

        eventLoop.dispatch(new EventLoop.Event("hello", "world!"));
        eventLoop.dispatch(new EventLoop.Event("foo", "bar"));

        //event registration with callbacks ; queue binding
        eventLoop
                .on("hello", s -> System.out.println("hello " + s))
                .on("tick", n -> System.out.println("tick #" + n))
                .on("stop", v -> eventLoop.stop())
                .run();

        System.out.println("Bye!");
    }

    private static void delay(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public EventLoop on(String key, Consumer<Object> handler) {
        handlers.put(key, handler);
        return this;
    }

    public void dispatch(Event event) {
        events.add(event);
    }

    public void run() {
        while (!(events.isEmpty() && Thread.interrupted())) {
            if (!events.isEmpty()) {
                Event event = events.pop();
                if (handlers.containsKey(event.key)) {
                    handlers.get(event.key).accept(event.data);
                } else {
                    System.err.println("No handler for key " + event.key);
                }
            }
        }
    }

    public void stop() {
        Thread.currentThread().interrupt();
    }

    public static final class Event {
        private final String key;
        private final Object data;

        public Event(String key, Object data) {
            this.key = key;
            this.data = data;
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup

-Maven Project
-Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project

Vetx Distribution:

-maven
-zip

download zip and extract and set path 
C:\softwares\vert.x-3.9.2-full\vertx\bin



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to run vertx application?

We have many ways:

1.via maven.

running:
./mvnw clean compile exec:java
or
mvn clean compile exec:java

2.fat jar running:

you can pack vertx application into fat jar and you can


1.Create fat jar

mvnw clean package

2. Running

java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar


3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java



3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
HTTP server started on port 8888
Succeeded in deploying verticle


4.via coding - to be discussed later

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx apps:

vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............

vertx-core:
..........
........................................................................................................
Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.


io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler).

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles


package com.example.myvertxapp;

import io.vertx.core.Vertx;

public class VertxInstanceCreation {
  public static void main(String[] args) {
    //create and start vertx engine
    Vertx myverx = Vertx.vertx();
    System.out.println(myverx.getClass().getName());
  }
}

/////////////////////////////////////////////////////////////////////////////////////////
Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loop threads.

Verticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment



How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}

How to deploy(run) the above code?

if you want to run any code, you need entry point-main method.

vertx provides entry method-main method called "Launcher"

Launcher is a program, which has built in main method.

In general , lanucher is "vertx" runtime command only

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;

public class HelloWorldVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    //application
    System.out.println("Hello verticle : start");
  }

  @Override
  public void stop() throws Exception {
    System.out.println("Hello verticle : Stop");

  }
}
///////////////////////////////////////////////////////////////////////////////////////////

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Verticle Deployment via coding:
...............................

In vertx , verticle deployment itself is async, which is non blocking.

Runner class ; it is utility class provided by vertx for deployment, it is very usefull for dev.


How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


How to run verticles via coding?


package com.example.myvertxapp;

import io.vertx.core.Vertx;

public class GreeterVerticle {
  public static void main(String[] args) {
    //way 1 : get vertx instance
    Vertx vertx = Vertx.vertx();
    //option1 ; create object for verticle class
    vertx.deployVerticle(new HelloWorldVerticle());
    //option 2 ; verticle class
    vertx.deployVerticle(HelloWorldVerticle.class.getName());
    //option 3 : verticle class string
    vertx.deployVerticle("com.example.myvertxapp.HelloWorldVerticle");
  }
}

////////////////////////////////////////////////////////////////////////////////////////

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import io.vertx.example.util.Runner;

public class GreeterVerticle extends AbstractVerticle {
  public static void main(String[] args) {

    Runner.runExample(GreeterVerticle.class);
//    //way 1 : get vertx instance
//    Vertx vertx = Vertx.vertx();
//    //option1 ; create object for verticle class
//    vertx.deployVerticle(new HelloWorldVerticle());
//    //option 2 ; verticle class
//    vertx.deployVerticle(HelloWorldVerticle.class.getName());
//    //option 3 : verticle class string
//    vertx.deployVerticle("com.example.myvertxapp.HelloWorldVerticle");

  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle("com.example.myvertxapp.HelloWorldVerticle");
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////

Threading model in vertx:

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Eg : Knowing the threads:

Note: every verticle by default bound with a thread - event loop thread
if no of verticles increases, vertx assigns each verticle with one thread. 
a single thread can bound with many verticles.

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

class MyVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("My verticle " + Thread.currentThread().getName());
  }
}

public class EventLoopThreadMainVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(EventLoopThreadMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Main Verticle " + Thread.currentThread().getName());
    for (int i = 1; i <= 30; i++)
      vertx.deployVerticle(new MyVerticle());
  }


}
////////////////////////////////////////////////////////////////////////////////////////////


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

How to process events 

-Verticle
-Event loop Thread
-Event handlers

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern : Functional/callback style
2.Reactive Pattern - RxJava2


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".



1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.

What is handler function/callback function/listener function for?
To handle async success /failure result.
   The result of async opertion could be either success or failure

////////////////////////////////////////////////////////////////////////////////////////////////////////


io.vertx.Future:

-it is interface used to handle async success/failure results.

io.vertx.core

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				         Future



Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.


Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure

AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success


Future Object creation and encaspulating data

1.Future future = Future.future()
 future.complete(T value)
 future.fail(T value)

2.static factory api
Future.succeedFuture(T value)
Future.FailedFuture(T value)

3.function as parameter pattern ; callback pattern

////////////////////////////////////////////////////////////////////////////////////////
package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;

class MessageServiceVerticle extends AbstractVerticle {

  //empty Empty future
  public Future<Void> getEmptyFuture() {
    //create Future Object
    Future<Void> future = Future.future();
    future.complete();
    return future;
  }

  //send data only
  public Future<String> getSuccessMessage() {
    //create Future Object
    Future<String> future = Future.future();
    future.complete("Hello!");
    return future;
  }

  //send error only
  public Future<String> getErrorMessage() {
    //create Future Object
    Future<String> future = Future.future();
    future.fail(new RuntimeException("SOmething went wrong"));
    return future;
  }

  //logic
  public Future<String> login(String userName, String password) {
    Future<String> future = Future.future();
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success");
    } else {
      future.fail(new RuntimeException("Login Failed"));
    }

    return future;
  }

  //Function as parameter
  public void processMessage(String message,Handler<AsyncResult<String>> asyncHandler) {
    //encasulate data
    if (message.equals("greet")) {
      asyncHandler.handle(Future.succeededFuture("You have Message"));
    } else {
      asyncHandler.handle(Future.failedFuture("You have no Message"));

    }
  }
  //static method to create future instance
  //create Future object using factory apis
  public Future<String> getHelloMessage() {
    //encapsulate response
    String message = "hello";
    if (message.equals("hello")) {
      return Future.succeededFuture("Yes Hello Message i got it");
    } else {
      return Future.failedFuture(new RuntimeException("No, i did not get any message"));
    }
  }


  @Override
  public void start() throws Exception {
    super.start();
    //process future.
    getEmptyFuture().setHandler(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println("Empty future called");
      } else {
      }
    });
    getEmptyFuture().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println("Empty future called");
      } else {
      }
    });
    //////////////////////////////////////////////////////////////////////////////////
    getSuccessMessage().onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      }
    });
    getSuccessMessage().onSuccess(message -> {
      System.out.println(message);
    });
    getSuccessMessage().onSuccess(System.out::println);

    /////////////////////////////////////////////////////////
    getErrorMessage().onComplete(asynResult -> {
      if (asynResult.failed()) {
        System.out.println(asynResult.cause());
      }
    });
    getErrorMessage().onFailure(error -> System.out.println(error));
    getErrorMessage().onFailure(System.out::println);

    login("admin", "admin").onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.failed());
      }
    });
    login("foo", "bar").onComplete(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    ////////////////////////////////////////////////////////////////
    processMessage("greet",asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });
    processMessage("foo",asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });

    ///static method processing
    getHelloMessage()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}


public class FutureMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FutureMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new MessageServiceVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////
Promises:
........

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.

Promises must be converted into Future before processing.
package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  //how to send success results : can be any type
//  public Promise<String> getSuccessPromise() {
//    //create Future object
//    Promise<String> promise = Promise.promise();
//    //empty response injection
//    promise.complete("Hello I am Promise result!!");
//    return promise;
//  }
  public Future<String> getSuccessPromise() {
    //create Future object
    Promise<String> promise = Promise.promise();
    //empty response injection
    promise.complete("Hello I am Promise result!!");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
   // getSuccessPromise().future().onSuccess(System.out::println);
    getSuccessPromise().onSuccess(System.out::println);
  }
}

public class PromiseMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserServiceVerticle extends AbstractVerticle {
  //getUser----login----showpage
  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String loginStatus) {
    Promise<String> promise = Promise.promise();
    if (loginStatus.equals("login success")) {
      promise.complete("You are admin");
    } else {
      promise.fail(new RuntimeException("You are guest"));
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();

    getUser().onComplete(userAsyncResult -> {
      System.out.println("Get user is called");
      if (userAsyncResult.succeeded()) {
        //call login method
        login(userAsyncResult.result()).onComplete(loginAsyncResult -> {
          System.out.println("login is called");
          if (loginAsyncResult.succeeded()) {
            //call showPage Method
            showPage(loginAsyncResult.result()).onComplete(pageAsyncResult -> {
              System.out.println("Show page is called");
              if (pageAsyncResult.succeeded()) {
                System.out.println(pageAsyncResult.result());
              } else {
                System.out.println(pageAsyncResult.cause());
              }
            });
          }

        });

      } else {
        System.out.println(userAsyncResult.cause());
      }
    });


  }
}


public class CallNestingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallNestingVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserServiceVerticle());
  }
}

Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!


can we escape from callback hell problem, how to write better callback based programming?

Yes! 

Composition of callbacks:compose method of Future & Promise 

Solution to callback Hell:
..........................

compose method of Future & Promise 

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserServiceVerticle extends AbstractVerticle {
  //getUser----login----showpage
  public Future<String> getUser() {
    System.out.println("Get user is called");
    Promise<String> promise = Promise.promise();
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail(new RuntimeException("User not found"));
    }
    return promise.future();
  }

  public Future<String> login(String userName) {
    System.out.println("login user is called");

    Promise<String> promise = Promise.promise();
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail(new RuntimeException("login failed"));
    }
    return promise.future();
  }

  public Future<String> showPage(String loginStatus) {
    System.out.println("show Page is called");

    Promise<String> promise = Promise.promise();
    if (loginStatus.equals("login success")) {
      promise.complete("You are admin");
    } else {
      promise.fail(new RuntimeException("You are guest"));
    }
    return promise.future();
  }

  public void callbackHellApi() {
    getUser().onComplete(userAsyncResult -> {
      System.out.println("Get user is called");
      if (userAsyncResult.succeeded()) {
        //call login method
        login(userAsyncResult.result()).onComplete(loginAsyncResult -> {
          System.out.println("login is called");
          if (loginAsyncResult.succeeded()) {
            //call showPage Method
            showPage(loginAsyncResult.result()).onComplete(pageAsyncResult -> {
              System.out.println("Show page is called");
              if (pageAsyncResult.succeeded()) {
                System.out.println(pageAsyncResult.result());
              } else {
                System.out.println(pageAsyncResult.cause());
              }
            });
          }

        });

      } else {
        System.out.println(userAsyncResult.cause());
      }
    });
  }

  public void composeApi() {
    getUser()
      .compose(user -> {
       // System.out.println("Get user is called");
        return login(user);
      })
      .compose(status -> {
      //  System.out.println("login is called");
        return showPage(status);
      })
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    //Refactoring using java lambdas
    getUser()
      .compose(user->login(user))
      .compose(status->showPage(status))
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
    //Method Reference Syntax
    getUser()
      .compose(this::login)
      .compose(this::showPage)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }


  @Override
  public void start() throws Exception {
    super.start();
    composeApi();

  }
}


public class CallNestingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CallNestingVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserServiceVerticle());
  }
}
////////////////////////////////////////////////////////////////////////////////////////////

Data formats:
............
Data Format in vertx:

1.Buffer
2.JSON object

Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferMainVerticle  extends AbstractVerticle{
  public static void main(String[] args) {
    Runner.runExample(BufferMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////////

JSON : Data interchange  staandard format, used in distributed computing to exchange data among software compoents.

json features
 - plain ascii string only.
string to object and object to string  : json processing - all languages provides json parsers
Jackson  is most popular  json parser for java.
Vertx and spring internally uses Jackson  paraser only.

io.vertx.core.json
 provides json paraser apis
Json	 
 parser
JsonArray	
  A representation of a JSON array in Java.
JsonObject	
  A representation of a JSON object in Java.


package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONMainVerticle.class);
  }

  //create json object
  public void createJson(){
    JsonObject profile = new JsonObject();
    profile.put("id",1);
    profile.put("name","Subramanian");
    profile.put("city","Coimbatore");
    //parsing
    System.out.println(profile.encodePrettily());
  }
  public void createNestedJson(){
    JsonObject profile = new JsonObject();
    profile.put("id",1);
    profile.put("name","Subramanian");
    profile.put("city","Coimbatore");
    JsonObject skills = new JsonObject();
    skills.put("id","Java");
    profile.put("skills",skills);
    //parsing
    System.out.println(profile.encodePrettily());
  }

  @Override
  public void start() throws Exception {
    super.start();
    createJson();
    createNestedJson();
  }
}
////////////////////////////////////////////////////////////////////////////////////////////

Are you fluent?
 fluent is a pattern to call methods on a object.
if you want to call multiple methods on a object, or same method with different arg.

"hello".trim().toUpperCase().toLowercase()-  fluent style

fluent pattern is other called as builder pattern /command chain pattern.

In Vertx , most of the api / 99% of the api been designed with fluent. it is recommended to use those patterns.

public void createJsonFluent() {
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "coimbatore")
      .put("skills", new JsonObject().put("skills", "Vertx"));
    System.out.println(profile.encodePrettily());
  }
/////////////////////////////////////////////////////////////////////////////////////////////

Json Array:
...........

  public void createJsonList() {
    JsonArray list = new JsonArray()
      .add(new JsonObject()
        .put("id", 1)
        .put("name", "Subramanian")
        .put("city", "coimbatore")
        .put("skills", new JsonObject().put("skills", "Vertx")))
      .add(new JsonObject()
        .put("id", 2)
        .put("name", "Ram")
        .put("city", "Chennai")
        .put("skills", new JsonObject().put("skills", "Devops")));
    System.out.println(list.encodePrettily());
  }
/////////////////////////////////////////////////////////////////////////////////////////////

Merging json properties with existing json structure.

  public void mergeJson(JsonObject jsonObject) {
    JsonObject appConfig = new JsonObject()
      .put("http.port", 8080)
      .mergeIn(jsonObject);
    System.out.println(appConfig.encodePrettily());

  }
    mergeJson(new JsonObject().put("http.port", 3000).put("http.host", "globallogic.com").put("http.ssl", true));
/////////////////////////////////////////////////////////////////////////////////////////

Future and JSON


  public Future<JsonObject> sendingJsonViaFuture() {
    Promise<JsonObject> promise = Promise.promise();
    JsonObject profile = new JsonObject()
      .put("id", 1)
      .put("name", "Subramanian")
      .put("city", "coimbatore")
      .put("skills", new JsonObject().put("skills", "Vertx"));
    promise.complete(profile);
    return promise.future();
  }
  sendingJsonViaFuture().onSuccess(profile -> {
      System.out.println(profile.encodePrettily());
    });
////////////////////////////////////////////////////////////////////////////////////////////

Vertx :
  Non Blocking applications.
  Non Blocking IO application.
  NOn blocking networking applications - TCP/HTTP/DNS..


Non blocking code can be written inside verticle or without verticle.
all nonblocking tasks are handled by "event loop threads"


In vertx most of actions are async, including deploying and undeploying verticles

While deploying verticle ,void deployVerticle(String name,
                    Handler<AsyncResult<String>> completionHandler)


Every verticle has deployment id, using this we can undeploy the verticle.


   vertx.deployVerticle(new TimersVerticle(), handler -> {
      if (handler.succeeded()) {
        System.out.println("TimersVerticle deployed successfully " + deploymentID());
      }
    });


Vertx.Core Non blocking apis:

Periodic and delayed actions:


 package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class TimersVerticle extends AbstractVerticle {

  public Future<JsonObject> delay(long delayTime) {
    //callee
//    vertx.setTimer(delayTime, handlerTime -> {
//      System.out.println("Timeout");
//    });
    Promise<JsonObject> promise = Promise.promise();
    vertx.setTimer(delayTime, handlerTime -> {
      boolean isSuccess = true;
      if (isSuccess) {
        //  return Future.succeededFuture(new JsonObject().put("message", "Greetings to Non blocking"));
        promise.complete(new JsonObject().put("message", "Greetings to Non blocking"));
      } else {
        //return Future.failedFuture(new RuntimeException(new JsonObject().put("message", "something went wrong").encodePrettily()));
        promise.fail(new RuntimeException(new JsonObject().put("message", "something went wrong").encodePrettily()));
      }
    });
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    super.start();
    System.out.println("start");
    //caller
    delay(5000)
      .onSuccess(message -> System.out.println(message.encodePrettily()))
      .onFailure(error -> System.out.println(error.getCause()));
    System.out.println("end");
  }
}


public class TimersMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimersMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new TimersVerticle(), handler -> {
      if (handler.succeeded()) {
        System.out.println("TimersVerticle deployed successfully " + deploymentID());
      }
    });
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Future,setPeriodic,Handler,Callback:
.....................................

  public void heartBeat(long timeout, Handler<AsyncResult<JsonObject>> aHandler) {
    long timerId = vertx.setPeriodic(timeout, handler -> {
      // System.out.println(new Date());
      aHandler.handle(Future.succeededFuture(new JsonObject().put("now", new Date().toString())));
    });
    //logic to cancel timer
    vertx.setTimer(10000, stopTimerId -> {
      System.out.println("Stopping Heart Beat");
      vertx.cancelTimer(timerId);
    });
  }
    heartBeat(1000, handler -> {
      if (handler.succeeded()) {
        System.out.println(handler.result().encodePrettily());
      }
    });
////////////////////////////////////////////////////////////////////////////////////////////

Without Verticle class how to write async/non blocking code? with plain java class.

package com.example.myvertxapp;

import io.vertx.core.Vertx;

public class NonBlockingWithoutVerticle {
  public static void main(String[] args) {
    System.out.println("Plain Java app is running on " + Thread.currentThread().getName());
    Vertx vertx = Vertx.vertx();

    vertx.setPeriodic(1000, aHandler -> {
      System.out.println("Periodic " + Thread.currentThread().getName());
      // vertx.close();
    });
    //without verticle i am creating timer non blocking.
    vertx.setTimer(5000, aHandler -> {
      System.out.println("Timer : " +Thread.currentThread().getName());
      // vertx.close();
    });
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////
NonBlocking IO Application Developement:

Generally in java all io apis are blocking.

Types of IO Apps:

1.file system IO
2.Networking io - http.

FileSystem:

Vertx offers non blocking and blocking version of file operations.

The non blocking versions take a handler(callback) which is called when the operation completes or an error occurs.

The blocking versions are named xxxBlocking and return the results, or throw exceptions directly

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

class FileOperations extends AbstractVerticle {

  public Future<String> readFile() {
    Promise<String> promise = Promise.promise();
    String filePath = "hello.txt";
    vertx.fileSystem().readFile(filePath, fileHandler -> {
      if (fileHandler.succeeded()) {
        // System.out.println("Read content: " + fileHandler.result());
        promise.complete(fileHandler.result().toString());
        //  promise.complete("fiel read is completed");
      } else {
        System.out.println("read failed");
        promise.fail(fileHandler.cause());
      }
    });
    return promise.future();
  }

  public Future<String> writeFile(String data) {
    Promise<String> promise = Promise.promise();
    String filePath = "greetings.txt";
    //String filePath = "src/main/resources/write.txt";
    vertx.fileSystem().writeFile(filePath, Buffer.buffer(data), fileHandler -> {
      if (fileHandler.succeeded()) {
        promise.complete("Write Operation is completed");
      } else {
        System.err.println("Error while writing in file: ");

        promise.fail(fileHandler.cause());
      }
    });

    return promise.future();
  }
  private Future<String> copyFile(String input) {
    Future<String> future = Future.future();

    // Retrieve a FileSystem object from vertx instance and call the
    // non-blocking writeFile method
    vertx.fileSystem().copy(input, "src/main/resources/example03/writecopy.txt", handler -> {
      if (handler.succeeded()) {
        System.out.println("Copy done of " + input);
        future.complete("Copy success");
      } else {
        System.err.println("Error while copying a file: " + handler.cause().getMessage());
        future.fail(handler.cause());
      }
    });

    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
    readFile().onSuccess(result -> {
      System.out.println(result);
    }).onFailure(fileError -> {
      System.out.println(fileError.getCause().getMessage());
    });
    vertx.setTimer(1000, handler -> {
      System.out.println("Timer async");
    });

    writeFile("Hello how are you?").onSuccess(result -> {
      System.out.println(result);
    }).onFailure(fileError -> {
      System.out.println(fileError.getCause().getMessage());
    });

    System.out.println("end");

  }
}


public class FileSystemVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FileSystemVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FileOperations());
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Types of IO :
 -Non Streaming IO
 -Streaming IO

What is non streaming?

 if you read file/write file, the entire file is loaded into vertx process mememory, then will
be delivered to the caller.
 if more files loaded into process memory, then which causes memory overflow, may slow down
the other application process.
 non streaming is not good for reading big files and files in network..

eg:
 vertx.fileSystem().readFile,writeFile,copy  methods are non stream methods.

Streaming:

  Streaming is nothing but io input source(file,network socket) is broken into smaller unit
called "chunk".
 chunk is part of while input source, will be delivered to called one by one.

                          io.vertx.core.streams.StreamBase
					|
                    io.vertx.core.streams.ReadStream
				|
                    io.vertx.core.file.AsyncFile

AsyncFile :
  Enables streaming mode
  Usefull for big files
  Usefull for networking application

Options Object:
...............
Most of Objects can be configured.

Configuration:			
 You can configure the entier vertx system using configuration echo system.

Eg: if you come from spring background, how do you implement configuration
Configuation Management System.
 -XML,JavaConfig
             ->Auto Configuration
                           -->Boot
Application configuration: How to supply data to application which is running/in production
  -properties
  -yaml

Is there is any configuration techniquie to configure the objects via code.
  very rare.

Vertx supports lot of configuration management:
 
1.Programmetic configuration - via Objects : Those Objects are called Configuration Objects
  Object configure other objects.

2.External Configuration : passing config data via fileSystem/Data Sources- properties,yaml
  -ldap,redis......


Programmetic Configuration:

 Generally Programmetic Configuration objects are called as "Options Object"
 XXXOptions

eg:

1.VertxOptions
   Config Object to Configure Vertx Engine.
2.DeploymentOptions
   ConfigObject to Configure Verticles.
3.FileSystemOptions
   ConfigObject to Configure FileSystem
4.OpenOptions
   Describes how an AsyncFile should be opened.
etc...
  Like we have many more configuration objects....

package com.example.myvertxapp;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.file.AsyncFile;
import io.vertx.core.file.OpenOptions;
import io.vertx.example.util.Runner;

public class StreamingVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(StreamingVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    OpenOptions opts = new OpenOptions().setRead(true);
    vertx.fileSystem().open("big.file", opts, ar -> {
      if (ar.succeeded()) {
        System.out.println("File open");
        //start reading file in streaming mode.
        AsyncFile file = ar.result();
        file.handler(System.out::println)
          .exceptionHandler(Throwable::printStackTrace)
          .endHandler(done -> {
            System.out.println("\n--- DONE");
            vertx.close();
          });
      } else {
        System.out.println(ar.cause());
      }
    });

  }
}
//////////////////////////////////////////////////////////////////////////////////////////////

Blocking Operations:
....................

Vertx is most pouplar for async programming:

->Vertx uses dedicated threads who handles all non blocking operations

vertx Engine components

1.Non blocking operations Thread pool : Event loop pool threads

2.Blocking operations thread pool : Worker Pool threads

3.Event Queue

4.Event loop thread
 -Listens for events from Async operation threads,
 -Assign event with handler(With Future/Promise) abstractions.
How many event loop?
 in node js, only one event loop.

 Vertx has many event loops, based on no of cpu cores
  lets say i have 12 core, 12 event loop will 
/////////////////////////////////////////////////////////////////////////////////////////////

Which operations are  blocking and which operations are non blocking?

1.Based on verticles
2.Based on blocking apis

Gloden Rules:
 Dont block event loop thread


Verticles Types:
................

1.Standard Verticle
  This is most common and usefull type.
  Standard verticles are processed by event loop Thread
  By default all verticles are event loop verticles

2.Worker Verticle
  It is verticle which is not processed by event loop any more, 
  Worker verticles are handled by special threads "Worker pool threads".






































